#include <SDL2/SDL.h>
#include <iostream>
#include <cmath> 
#include <algorithm> // for std::max

#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600
#define MAX_BULLETS 1000000
#define PI 3.14159265

// ------------------------------------------------
// 基礎向量類別
// ------------------------------------------------
class Vec {
public:
    float vx, vy;
    Vec(float vx = 0, float vy = 0) : vx(vx), vy(vy) {}
    void setSpeed(float sx, float sy) {
        vx = sx;
        vy = sy;
    }
};

// ------------------------------------------------
// 擴展子彈類別 (新增 accel 和 curve)
// ------------------------------------------------
class AdvancedBullet : public Vec {
public:
    float x, y;
    bool active;
    float direction;
    float speed;
    float accel;
    float curve;

    AdvancedBullet() : Vec(), direction(0), speed(0), accel(0), curve(0) {
        active = false;
    }

    void fire(float startX, float startY, float v, float theta, float a, float c) {
        x = startX;
        y = startY;
        direction = theta;
        speed = v;
        accel = a;
        curve = c;
        active = true;
        setSpeed(speed * cos(direction), speed * sin(direction));
    }

    void update(float dt) {
        if (!active) return;
        direction += curve * dt;
        speed += accel * dt;
        vx = speed * cos(direction);
        vy = speed * sin(direction);
        x += vx * dt;
        y += vy * dt;
        if (x < 0 || x > SCREEN_WIDTH || y < 0 || y > SCREEN_HEIGHT || speed < 0)
            active = false;
    }
};

// ------------------------------------------------
// 全域子彈管理實體
// ------------------------------------------------
AdvancedBullet advanced_bullets[MAX_BULLETS];

void shootAdvancedBullet(float x, float y, float v, float theta = 0.0f, float accel = 0.0f, float curve = 0.0f) {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!advanced_bullets[i].active) {
            advanced_bullets[i].fire(x, y, v, theta, accel, curve);
            break;
        }
    }
}

void updateAdvancedBullets(float dt) {
    for (int i = 0; i < MAX_BULLETS; i++)
        advanced_bullets[i].update(dt);
}

void renderAdvancedBullets(SDL_Renderer* renderer) {
    // 優化建議：使用 SDL_RenderDrawPoints 以提高繪圖效率
    SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255);
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (advanced_bullets[i].active) {
            SDL_Rect rect = { (int)advanced_bullets[i].x, (int)advanced_bullets[i].y, 1, 1 };
            SDL_RenderFillRect(renderer, &rect);
        }
    }
}

// ------------------------------------------------
// GMS 彈幕控制類別 (單一且正確的定義)
// ------------------------------------------------
class GMSBulletPattern {
public:
    int total_arrays = 1;
    int bullets = 10;
    float array_spread_total = PI * 2;
    float spread = PI / 4.0f;
    float base_angle = 0.0f;
    float start_angle = 0.0f;
    float bullet_speed = 150.0f;
    float bullet_accel = 0.0f;
    float bullet_curve = 0.0f;
    float x_offset = 0.0f;
    float y_offset = 0.0f;
    float object_width = 0.0f;
    float object_height = 0.0f;
    int fire_rate = 10;
    float spin = 0.0f;
    float spin_mod = 0.0f;
    float max_spin_spd = PI/2.0f;
    bool spin_reverse = false;

private:
    float shoot_timer = 0.0f;

public:
    // **初始化函式 (init)**: 設置所有彈幕參數
    void init(
        int num_bullets, float bullet_spread, float initial_angle,
        int num_arrays, float array_spread_total_arg,
        float begin_spin, float spin_change_rate, bool reverse_spin, float max_spin,
        int rate_of_fire,
        float obj_width, float obj_height, float off_x, float off_y
    )
    {
        base_angle = 0.0f;
        shoot_timer = 0.0f;
        bullets = num_bullets;
        spread = bullet_spread;
        start_angle = initial_angle;
        total_arrays = num_arrays;
        array_spread_total = array_spread_total_arg;
        spin = begin_spin;
        spin_mod = spin_change_rate;
        spin_reverse = reverse_spin;
        max_spin_spd = max_spin;
        fire_rate = rate_of_fire;
        object_width = obj_width;
        object_height = obj_height;
        x_offset = off_x;
        y_offset = off_y;
    }

    // **更新與發射函式 (updateAndFire)**: 執行 GMS 彈幕邏輯
    void updateAndFire(float dt, float x, float y) {
        shoot_timer += dt;
        const float FPS = 60.0f;
        float fire_interval = fire_rate / FPS;

        if (shoot_timer >= fire_interval) {
            shoot_timer = 0.0f;

            // 角度步進計算
            int bb = std::max(1, bullets - 1); // 避免除以零
            int aa = std::max(1, total_arrays - 1); // 避免除以零

            float a_ang = (array_spread_total / aa); // 陣列間角度步進
            float b_ang = (spread / bb);             // 陣列內子彈角度步進

            for (int j = 0; j < total_arrays; j++) {
                for (int i = 0; i < bullets; i++) {
                    float current_angle = base_angle + (b_ang * i) + (a_ang * j) + start_angle;

                    // lengthdir 邏輯: 決定發射點
                    float xx = x + x_offset + object_width * cos(current_angle);
                    float yy = y + y_offset + object_height * sin(current_angle);

                    ::shootAdvancedBullet(
                        xx, yy,
                        bullet_speed,
                        current_angle,
                        bullet_accel,
                        bullet_curve
                    );
                }
            }

            // 旋轉更新邏輯
            base_angle += spin;
            spin += spin_mod;

            if (spin_reverse) {
                if (spin < -max_spin_spd || spin > max_spin_spd) {
                    spin_mod = -spin_mod;
                }
            }
        }
    }
};

// ------------------------------------------------
// 全域實例化 (只做一次)
// ------------------------------------------------
GMSBulletPattern StarSpiral;

void setupStarSpiralPattern() {
    // 使用 init 函式來設定彈幕
    StarSpiral.init(
        6,          // num_bullets
        PI/8.0f,    // bullet_spread
        PI/4.0f,    // initial_angle
        4,          // num_arrays
        2 * PI,     // array_spread_total_arg (360 度)
        0.05f,      // begin_spin
        0.001f,     // spin_change_rate
        true,       // reverse_spin
        0.2f,       // max_spin
        5,          // rate_of_fire
        20.0f,      // obj_width (從玩家邊緣發射)
        20.0f,      // obj_height
        0.0f,       // off_x
        0.0f        // off_y
    );
}

int main(int argc, char* argv[]) {
    // 1. 在迴圈開始前呼叫初始化
    setupStarSpiralPattern();

    // ... SDL 初始化代碼 (不變)
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window* window = SDL_CreateWindow(
        "SDL Bullet Demo",
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
        SCREEN_WIDTH, SCREEN_HEIGHT, 0
    );
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    bool running = true;
    SDL_Event event;
    Uint32 lastTime = SDL_GetTicks();
    float playerX = 100, playerY = 300;

    while (running) {
        Uint32 current = SDL_GetTicks();
        float dt = (current - lastTime) / 1000.0f;
        lastTime = current;

        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT)
                running = false;

            if (event.type == SDL_KEYDOWN) {
                switch(event.key.keysym.sym) {
                    case SDLK_SPACE:
                        // 範例：切換速度
                        StarSpiral.bullet_speed = (StarSpiral.bullet_speed == 100.0f) ? 200.0f : 100.0f;
                        break;
                    case SDLK_RETURN:
                        // 範例：臨時加速旋轉
                        StarSpiral.spin = 0.1f;
                        break;
                }
            }
        }

        // 核心更新邏輯
        StarSpiral.updateAndFire(dt, playerX, playerY);
        updateAdvancedBullets(dt);

        // 渲染
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_Rect player = { (int)playerX, (int)playerY, 20, 20 };
        SDL_RenderFillRect(renderer, &player);
        renderAdvancedBullets(renderer);
        SDL_RenderPresent(renderer);
    }

    // SDL 清理代碼 (確保只在 main 結束前執行一次)
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
